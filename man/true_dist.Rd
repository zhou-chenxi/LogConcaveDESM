% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/true_distributions.R
\name{true_dist}
\alias{true_dist}
\alias{truncated_normal}
\alias{truncated_gamma}
\alias{truncated_lognormal}
\alias{beta_dist}
\title{True Distributions}
\usage{
truncated_normal(parent_mean, parent_sd, domain)

truncated_gamma(parent_shape, parent_rate, domain)

truncated_lognormal(parent_meanlog, parent_sdlog, domain)

beta_dist(shape1, shape2)
}
\arguments{
\item{parent_mean}{A numeric of the mean parameter in the parent normal distribution.}

\item{parent_sd}{A numeric of the standard deviation parameter in the parent normal distribution;
must be strictly positive.}

\item{domain}{A numeric vector of the domain over which the distribution is
defined; must be bounded and must not contain \code{Inf} or \code{-Inf}.}

\item{parent_shape}{A numeric of the shape parameter in the parent gamma distribution;
must be strictly positive.}

\item{parent_rate}{A numeric of the rate parameter in the parent gamma distribution;
must be strictly positive.}

\item{parent_meanlog}{A numeric of the mean parameter in the parent log-normal distribution
in the log scale.}

\item{parent_sdlog}{A numeric of the standard deviation parameter in
the parent log-normal distribution in the log scale.}

\item{shape1, shape2}{Numeric values of the parameters in the parent beta distribution;
must be strictly positive.}
}
\value{
An object of class "truncated_normal", "truncated_gamma", "truncated_lognormal",
or "beta_dist", whose underlying structure is a list containing the following elements
\describe{
    \item{sampling}{function: generates random samples from the underlying distribution.
    The input is \code{sample_size}, the number of desired samples, and the output is
    a numeric vector of random samples. }
    \item{evaluate_density}{function: returns the underlying density
    values. The input is \code{newx}, the points at which the density function
    is to be evaluated, and the output is a data frame with the first column being
    the sorted \code{newx} and the second column being the corresponding density values.}
    \item{evaluate_logderiv1}{function: returns the first derivative values
    of the logarithm of the underlying density function.
    The input is \code{newx}, the points at which the first derivative
    is to be evaluated, and the output is a data frame with the first column being
    the sorted \code{newx} and the second column being the corresponding first derivative
    values.}
    \item{domain}{numeric: a numeric vector over which the density function is defined.}
}
}
\description{
Functions for drawing random samples from the specified distribution and
evaluating the underlying density function and the first derivative of its logarithm.
}
\examples{
library(ggplot2)
######################################
# truncated normal
parent_mean <- 4
parent_sd <- 1
domain <- c(2, 5)
t_normal <- truncated_normal(parent_mean, parent_sd, c(2, 5))

# ------------------------------------
# sampling function
samples <- t_normal$sampling(10000)
df <- data.frame(x = samples)
x <- seq(domain[1], domain[2], by = 0.01)
y <- (dnorm(x, parent_mean, parent_sd) /
(pnorm(domain[2], parent_mean, parent_sd) -
pnorm(domain[1], parent_mean, parent_sd)))
density_df <- data.frame(x = x, y = y)
# use the Freedman-Diaconis rule for the binwidth
binwidth <- 2 * IQR(samples) / (length(samples) ** (1/3))
plot <- ggplot() +
geom_histogram(data = df, aes(x = x, y = ..density..),
binwidth = binwidth, color = "darkblue", fill = "lightblue") +
geom_line(data = density_df, aes(x = x, y = y), color = "black", size = 0.75) +
theme_bw()
plot

# ------------------------------------
# evaluate density
t_normal$evaluate_density(seq(-5, 10, by = 0.1))

# ------------------------------------
# evaluate derivative of log-density
t_normal$evaluate_logderiv1(seq(-5, 10, by = 0.1))

######################################
# truncated gamma
domain <- c(0, 10)
parent_shape <- 5
parent_rate <- 1
t_gamma <- truncated_gamma(parent_shape, parent_rate, domain)

# ------------------------------------
# sampling function
samples <- t_gamma$sampling(10000)
df <- data.frame(x = samples)
x <- seq(domain[1], domain[2], by = 0.01)
y <- (dgamma(x, parent_shape, parent_rate) /
(pgamma(domain[2], parent_shape, parent_rate) -
pgamma(domain[1], parent_shape, parent_rate)))
density_df <- data.frame(x = x, y = y)
# use the Freedman-Diaconis rule for the binwidth
binwidth <- 2 * IQR(samples) / (length(samples) ** (1/3))
plot <- ggplot() +
geom_histogram(data = df, aes(x = x, y = ..density..),
binwidth = binwidth, color = "darkblue", fill = "lightblue") +
geom_line(data = density_df, aes(x = x, y = y), color = "black", size = 0.75) +
theme_bw()
plot

# ------------------------------------
# evaluate density
t_gamma$evaluate_density(seq(-5, 10, by = 0.1))

# ------------------------------------
# evaluate derivative of log-density
t_gamma$evaluate_logderiv1(seq(-5, 10, by = 0.1))

######################################
# truncated lognormal
parent_meanlog <- 0
parent_sdlog <- 1/4
domain <- c(0, 5)
t_lognormal <- truncated_lognormal(parent_meanlog, parent_sdlog, domain)

# ------------------------------------
# sampling function
samples <- t_lognormal$sampling(10000)
df <- data.frame(x = samples)
x <- seq(domain[1], domain[2], by = 0.01)
y <- (dlnorm(x, parent_meanlog, parent_sdlog) /
(plnorm(domain[2], parent_meanlog, parent_sdlog) -
plnorm(domain[1], parent_meanlog, parent_sdlog)))
density_df <- data.frame(x = x, y = y)
# use the Freedman-Diaconis rule for the binwidth
binwidth <- 2 * IQR(samples) / (length(samples) ** (1/3))
plot <- ggplot() +
geom_histogram(data = df, aes(x = x, y = ..density..),
binwidth = binwidth, color = "darkblue", fill = "lightblue") +
geom_line(data = density_df, aes(x = x, y = y), color = "black", size = 0.75) +
theme_bw()
plot

# ------------------------------------
# evaluate density
t_lognormal$evaluate_density(seq(-5, 10, by = 0.1))

# ------------------------------------
# evaluate derivative of log-density
t_lognormal$evaluate_logderiv1(seq(-5, 10, by = 0.1))

######################################
# beta distribution
shape1 <- 4
shape2 <- 2
domain <- c(0, 1)
b <- beta_dist(shape1, shape2)

# ------------------------------------
# sampling function
samples <- b$sampling(10000)
df <- data.frame(x = samples)
x <- seq(domain[1], domain[2], by = 0.01)
y <- dbeta(x, shape1, shape2)
density_df <- data.frame(x = x, y = y)
# use the Freedman-Diaconis rule for the binwidth
binwidth <- 2 * IQR(samples) / (length(samples) ** (1/3))
plot <- ggplot() +
geom_histogram(data = df, aes(x = x, y = ..density..),
binwidth = binwidth, color = "darkblue", fill = "lightblue") +
geom_line(data = density_df, aes(x = x, y = y), color = "black", size = 0.75) +
theme_bw()
plot

# ------------------------------------
# evaluate density
b$evaluate_density(seq(0, 1, by = 0.1))

# ------------------------------------
# evaluate derivative of log-density
b$evaluate_logderiv1(seq(0, 1, by = 0.1))

}
